const _ФУНКЦИЯ = 'функция';
const _СВОЙСТВО = 'свойство';
const _ОПИСАНИЕ = '_описание';
const _ТИП = '_тип';
const _СВОйСТВА = '_свойства';

const _таблицаСправки = {
  элемент: {
    [_ОПИСАНИЕ]: 'Представляет собой функцию для работы с элементами. Возвращает обертку вокруг элемента с методами, перечисленными ниже. В качестве аргумента принимает либо CSS-селектор, либо элемент',
    [_ТИП]: _ФУНКЦИЯ,
    [_СВОйСТВА]: 'элемент: htmlElement || селектор: string',
    создать: {
      [_ОПИСАНИЕ]: 'Коллекция методов для создания элементов',
      элемент: {
        [_ОПИСАНИЕ]: 'Представляет собой функцию для создания элементов. Возвращает обертку вокруг нового элемената. В качестве аргументов принимает объект со свойствами',
        [_ТИП]: _ФУНКЦИЯ,
        [_СВОйСТВА]: '{ содержимое: string, класс: string, типЭлемента: string, стиль: объектСтилей, ссылка: строка, айди: строка }',
      }
    },
    добавитьКласс: {
      [_ОПИСАНИЕ]: 'Добавляет CSS-класс к элементу',
      [_ТИП]: _ФУНКЦИЯ,
      [_СВОйСТВА]: 'имяКласса: string',
    },
    удалитьКласс: {
      [_ОПИСАНИЕ]: 'Удаляет CSS-класс у элемента',
      [_ТИП]: _ФУНКЦИЯ,
      [_СВОйСТВА]: 'имяКласса: string',
    },
    переключитьКласс: {
      [_ОПИСАНИЕ]: 'Удаляет CSS-класс у элемента, если он есть, иначе он добавляется',
      [_ТИП]: _ФУНКЦИЯ,
      [_СВОйСТВА]: 'имяКласса: string',
    },
    стиль: {
      [_ОПИСАНИЕ]: 'Применяет CSS стили к объекту. CSS-стили принимаются в виде объекта, со стилями, описанными ниже <br/>' + получитьТаблицу(таблицаСоответствийСвойствСтилей, (описание) => { const названиеСвойства = таблицаСоответствийСвойствСтилей[ключ].replace( /([A-Z])/g, " $1" ).split(' ').join('-').toLowerCase(); return `<b>${названиеСвойства}</b>, подробнее в <a href="http://htmlbook.ru/css/${названиеСвойства}">htmlbook.ru</a> или <a href="https://developer.mozilla.org/ru/docs/Web/CSS/${названиеСвойства}">developer.mozilla.org</a>`  }),
      [_ТИП]: _ФУНКЦИЯ,
      [_СВОйСТВА]: 'имяКласса: string',
    },
    событие: {
      [_ОПИСАНИЕ]: 'Создает событие для элемента, например при нажатии' + получитьТаблицу(таблицаДействий, (описание) => { const названиеСвойства = описание.toLowerCase(); return `Создает событие ${названиеСвойства}`  } ),
      [_ТИП]: _ФУНКЦИЯ,
      [_СВОйСТВА]: 'имяКласса: string',
    },
    переключениеПоказа: {
      [_ОПИСАНИЕ]: 'Переключает свойство показа, в качестве аргумента принимает значение свойствоПоказа для видимого элемента, например block',
      [_ТИП]: _ФУНКЦИЯ,
      [_СВОйСТВА]: 'свойствоПоказа: string',
    }
  },
  переменная: {
    [_ОПИСАНИЕ]: 'Позволяет работать с собственным пространством переменных. При передаче одного аргумента - возврашает значение переменной, при передаче двух - создает/изменяет переменную',
    [_ТИП]: _ФУНКЦИЯ,
    [_СВОйСТВА]: 'имяПеременной: string, значениеПеременной: any',
  },
  константа: {
    [_ОПИСАНИЕ]: 'Позволяет работать с собственным пространством переменных. При передаче одного аргумента - возврашает значение переменной, при передаче двух - создает переменную. Если переменная уже была объявлена, то изменить ее нельзя',
    [_ТИП]: _ФУНКЦИЯ,
    [_СВОйСТВА]: 'имяПеременной: string, значениеПеременной: any',
  },
  получить: {
    [_ОПИСАНИЕ]: 'Находит искомое свойство в родителе и возвращает его, если путь неверный или свойство не найдено - возвращает значение по умолчанию',
    [_ТИП]: _ФУНКЦИЯ,
    [_СВОйСТВА]: 'объектРодитель: Object, путьДоСвойства: string, значениеПоУмолчанию: any',
  },
  формат: {
    [_ОПИСАНИЕ]: 'Форматирование строки в разных стилях',
    [_ТИП]: _СВОЙСТВО,
    змеиноеФорматирование: {
      [_ОПИСАНИЕ]: 'Преобразует строку в змеинный_стиль. В качестве аргументов принимает строку со словами через пробел, а так же флаг реверса, по умолчанию false. Если флаг реверса true, то тогда строку из змеиного форматирования бреобразует в обычное',
      [_ТИП]: _ФУНКЦИЯ,
      [_СВОйСТВА]: 'строка: string, реверс: boolean = false',
    },
    кебабФорматирование: {
      [_ОПИСАНИЕ]: 'Преобразует строку в кебаб-стиль. В качестве аргументов принимает строку со словами через пробел, а так же флаг реверса, по умолчанию false. Если флаг реверса true, то тогда строку из кебаб-стиля бреобразует в обычное',
      [_ТИП]: _ФУНКЦИЯ,
      [_СВОйСТВА]: 'строка: string, реверс: boolean = false',
    },
    верблюжьеФорматирование: {
      [_ОПИСАНИЕ]: 'Преобразует строку в веблюжийСтиль. В качестве аргументов принимает строку со словами через пробел, а так же флаг реверса, по умолчанию false. Если флаг реверса true, то тогда строку из верблюжьего форматирования бреобразует в обычное',
      [_ТИП]: _ФУНКЦИЯ,
      [_СВОйСТВА]: 'строка: string, реверс: boolean = false',
    },
    паскальФорматирование: {
      [_ОПИСАНИЕ]: 'Преобразует строку в ПаскальСтиль. В качестве аргументов принимает строку со словами через пробел, а так же флаг реверса, по умолчанию false. Если флаг реверса true, то тогда строку из паскаль форматирования бреобразует в обычное',
      [_ТИП]: _ФУНКЦИЯ,
      [_СВОйСТВА]: 'строка: string, реверс: boolean = false',
    }
  },
  
}





// добавление создания различных элементов в справку

for (ключ in таблицаСоответствийЭлементов) {
  _таблицаСправки.элемент.создать[ключ] = {
    [_ОПИСАНИЕ]: _таблицаСправки.элемент.создать.элемент[_ОПИСАНИЕ].replace('Представляет собой функцию для создания элементов', `Представляет собой функцию для создания элемента ${таблицаСоответствийЭлементов[ключ]}`),
    [_ТИП]: _ФУНКЦИЯ,
    [_СВОйСТВА]: _таблицаСправки.элемент.создать.элемент[_СВОйСТВА].replace(' типЭлемента: string,', ''),

  }
}


function получитьТаблицу(таблица, функцияДляОписания) {
  let итоговаяТаблица = '<table>';
  for (ключ in таблица) {
    const описаниеСвойства = функцияДляОписания(таблица[ключ]);
    итоговаяТаблица += `<tr><td>${ключ}</td><td>${описаниеСвойства}</td></tr>`;
  }
  итоговаяТаблица += '</table>';
  
  return итоговаяТаблица;
}

const _справка = (путьДоМетода, вернутьHtml = false) => {
  if (!путьДоМетода) {
    return получитьВсеКлючиСправки().map((ключСправки) => _справка(ключСправки, вернутьHtml));
  }
  const ошибкаНеизвестногоПути = new Error('Ошибка: неизвестный путь');
  const разобранныйПуть = путьДоМетода.split('.');
  if (разобранныйПуть[0] !== 'Ы') {
    return ошибкаНеизвестногоПути;
  }
  let искомыйМетод = _таблицаСправки;
  let произошлаОшибка = false;
  let справкаИскомогоМетода = '';
  разобранныйПуть.forEach((частьПути, индекс, массивПути) => {
    if (индекс === 0) {
      return
    }

    if (!искомыйМетод || !искомыйМетод[частьПути]) {
      произошлаОшибка = ошибкаНеизвестногоПути;
      return;
    }
    искомыйМетод = искомыйМетод[частьПути];
    if (индекс + 1 !== массивПути.length) {
      return
    }
    if (искомыйМетод[_ТИП] === _ФУНКЦИЯ) {
      справкаИскомогоМетода = `<p><b>${путьДоМетода}()</b></p>
        <div>
          <div><div class="блокКода">${путьДоМетода}( ${искомыйМетод[_СВОйСТВА]} )</div></div>
          <div>${искомыйМетод[_ОПИСАНИЕ]}</div>
        </div>
      `;
      if (!вернутьHtml) справкаИскомогоМетода = справкаИскомогоМетода.replace(/<\/?[a-zA-Z]+>/g, '')
    } else {
      const массивМетодов = []
      for (ключ in искомыйМетод) {
        if (ключ !== _ОПИСАНИЕ && ключ !== _ТИП && ключ !== _СВОйСТВА) {
        массивМетодов.push(путьДоМетода + '.' + ключ + (искомыйМетод[ключ][_ТИП] === _ФУНКЦИЯ ? '()' : ''));
        }
      }
      справкаИскомогоМетода = `<p><b>${путьДоМетода}</b></p>
        <div>
          <div><div class="блокКода">${путьДоМетода}</div></div>
          <div>${искомыйМетод[_ОПИСАНИЕ]}. Включает в себя следующие методы и свойства: <ul><li><b>${массивМетодов.join('</b></li><li><b>')}</b></li></ul></div>
        </div>
      `;
    }
  });
  if (произошлаОшибка) {
    return произошлаОшибка;
  }
  return справкаИскомогоМетода;
}

const получитьВсеКлючиСправки = (текущийПутьСтрокой = 'Ы') => {
  let списокСвойств = [];
  let текущийПутьМассив = текущийПутьСтрокой ? текущийПутьСтрокой.split('.') : false;

  let текущийПуть = _таблицаСправки;
  if (текущийПутьМассив) {
    текущийПутьМассив.forEach((ключ, индекс) => {
      if (индекс != 0) {
        текущийПуть = текущийПуть[ключ];
      }
    });
  }
  if (текущийПуть.length <= 3) {
    return списокСвойств;
  };
  for (ключ in текущийПуть) {
    if (ключ !== _ОПИСАНИЕ && ключ !== _ТИП && ключ !== _СВОйСТВА) {
      let путьСтрокойНовогоСвойства = текущийПутьСтрокой + '.' + ключ;
      if (!текущийПутьМассив) {
        путьСтрокойНовогоСвойства = ключ;
      }
      списокСвойств.push(путьСтрокойНовогоСвойства);
      const списокПодСвойств = получитьВсеКлючиСправки(путьСтрокойНовогоСвойства);
      списокСвойств = списокСвойств.concat(списокПодСвойств);
    }
  }
  return списокСвойств;
}

Ы.справка = _справка;